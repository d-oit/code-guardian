name: Enhanced Release Management

# Immutable release practices
permissions:
  contents: write
  packages: read

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to create enhanced release for'
        required: true
        type: string

concurrency:
  group: enhanced-release-${{ github.ref || github.event.inputs.tag }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  enhance-release:
    name: Enhance Release Description
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      with:
        fetch-depth: 0

    - name: Determine tag
      id: tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        fi

    - name: Extract version info
      id: version
      run: |
        TAG="${{ steps.tag.outputs.tag }}"
        VERSION=${TAG#v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        # Determine release type
        if [[ "$VERSION" == *"-alpha"* ]]; then
          echo "type=alpha" >> $GITHUB_OUTPUT
          echo "emoji=âš ï¸" >> $GITHUB_OUTPUT
        elif [[ "$VERSION" == *"-beta"* ]]; then
          echo "type=beta" >> $GITHUB_OUTPUT
          echo "emoji=ðŸš§" >> $GITHUB_OUTPUT
        elif [[ "$VERSION" == *"-"* ]]; then
          echo "type=prerelease" >> $GITHUB_OUTPUT
          echo "emoji=ðŸ”¬" >> $GITHUB_OUTPUT
        elif [[ "$VERSION" == "0.1.0" ]]; then
          echo "type=initial" >> $GITHUB_OUTPUT
          echo "emoji=ðŸŽ‰" >> $GITHUB_OUTPUT
        else
          echo "type=stable" >> $GITHUB_OUTPUT
          echo "emoji=" >> $GITHUB_OUTPUT
        fi

    - name: Generate enhanced release notes
      id: notes
      run: |
        TAG="${{ steps.tag.outputs.tag }}"
        VERSION="${{ steps.version.outputs.version }}"
        TYPE="${{ steps.version.outputs.type }}"
        EMOJI="${{ steps.version.outputs.emoji }}"
        
        # Get existing release notes from release-please or git-cliff
        EXISTING_NOTES=""
        if gh release view "$TAG" --json body --jq .body >/dev/null 2>&1; then
          EXISTING_NOTES=$(gh release view "$TAG" --json body --jq .body)
        fi
        
        # Parse existing notes to extract sections
        ADDED_SECTION=""
        FIXED_SECTION=""
        CHANGED_SECTION=""
        PERFORMANCE_SECTION=""
        DOCS_SECTION=""
        MAINTENANCE_SECTION=""
        
        # Extract sections from existing notes (simplified parsing)
        if [ -n "$EXISTING_NOTES" ]; then
          # Look for common patterns in release-please generated notes
          ADDED_SECTION=$(echo "$EXISTING_NOTES" | grep -A 10 -i "### .*[Aa]dded\|### .*[Ff]eatures\|### .*[Nn]ew" | grep "^- " || echo "")
          FIXED_SECTION=$(echo "$EXISTING_NOTES" | grep -A 10 -i "### .*[Ff]ixed\|### .*[Bb]ug" | grep "^- " || echo "")
          CHANGED_SECTION=$(echo "$EXISTING_NOTES" | grep -A 10 -i "### .*[Cc]hanged\|### .*[Mm]odified" | grep "^- " || echo "")
        fi
        
        # Create enhanced release notes
        cat > enhanced_notes.md << 'EOF'
        ## Code Guardian v$VERSION $EMOJI
        
        EOF
        
        # Add type-specific sections
        if [ "$TYPE" = "initial" ]; then
          cat >> enhanced_notes.md << 'EOF'
          ### ðŸš€ Initial Release
          Welcome to Code Guardian - A powerful Rust-based code analysis and security scanning tool!
          
          ### âœ¨ Features
          - Comprehensive code scanning and analysis capabilities
          - Security vulnerability detection
          - Modular architecture with multiple crates (CLI, Core, Output, Storage)
          - Multiple output formats (JSON, HTML, Markdown, CSV, Text)
          - High-performance scanning engine
          - Extensible detector system
          
          ### ðŸ› ï¸ Architecture
          - **CLI**: Command-line interface for user interaction
          - **Core**: Main scanning engine and detection logic
          - **Output**: Multiple formatter support for results
          - **Storage**: Data persistence and caching
          
          EOF
        elif [ "$TYPE" = "alpha" ] || [ "$TYPE" = "beta" ] || [ "$TYPE" = "prerelease" ]; then
          cat >> enhanced_notes.md << 'EOF'
          ### âš ï¸ Note
          This is a $TYPE release for testing new features and improvements. Please report any issues you encounter.
          
EOF
        fi
        
        # Add content sections based on what we found
        if [ -n "$ADDED_SECTION" ]; then
          echo "### âœ¨ Added" >> enhanced_notes.md
          echo "$ADDED_SECTION" >> enhanced_notes.md
          echo "" >> enhanced_notes.md
        fi
        
        if [ -n "$FIXED_SECTION" ]; then
          echo "### ðŸ› Fixed" >> enhanced_notes.md
          echo "$FIXED_SECTION" >> enhanced_notes.md
          echo "" >> enhanced_notes.md
        fi
        
        if [ -n "$CHANGED_SECTION" ]; then
          echo "### ðŸ”„ Changed" >> enhanced_notes.md
          echo "$CHANGED_SECTION" >> enhanced_notes.md
          echo "" >> enhanced_notes.md
        fi
        
        # Add standard sections
        cat >> enhanced_notes.md << 'EOF'
        ### ðŸ“¦ Assets
        - Pre-built binaries for Linux (x86_64), macOS (Intel & Apple Silicon), and Windows
        - Full source code archives
        
        ### ðŸš€ Installation
        \`\`\`bash
        # Download and extract the appropriate binary for your platform
        # Or install from source:
        cargo install --git https://github.com/d-oit/code-guardian
        \`\`\`
        
        ### ðŸ”— Links
        - [Installation Guide](https://github.com/d-oit/code-guardian#installation)
        - [Documentation](https://github.com/d-oit/code-guardian/tree/main/docs)
        - [Changelog](https://github.com/d-oit/code-guardian/blob/main/CHANGELOG.md)
        EOF
        
        # Add celebration for initial release
        if [ "$TYPE" = "initial" ]; then
          echo "" >> enhanced_notes.md
          echo "Thank you for trying Code Guardian! ðŸ›¡ï¸" >> enhanced_notes.md
        fi
        
        # Store the notes for the next step
        echo "ENHANCED_NOTES<<EOF" >> $GITHUB_ENV
        cat enhanced_notes.md >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update release description
      run: |
        TAG="${{ steps.tag.outputs.tag }}"
        
        # Check if release exists
        if gh release view "$TAG" >/dev/null 2>&1; then
          echo "Updating existing release $TAG..."
          gh release edit "$TAG" --notes "$ENHANCED_NOTES"
        else
          echo "Release $TAG not found. Creating new release..."
          # Determine if it's a prerelease
          if [[ "${{ steps.version.outputs.type }}" == "alpha" ]] || [[ "${{ steps.version.outputs.type }}" == "beta" ]] || [[ "${{ steps.version.outputs.type }}" == "prerelease" ]]; then
            gh release create "$TAG" --title "Code Guardian $TAG" --notes "$ENHANCED_NOTES" --prerelease
          else
            gh release create "$TAG" --title "Code Guardian $TAG" --notes "$ENHANCED_NOTES"
          fi
        fi
        
        echo "âœ… Release description enhanced successfully!"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  trigger-build:
    name: Trigger Release Build
    needs: enhance-release
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
    - name: Trigger release build workflow
      run: |
        echo "Release description enhanced. Release build workflow should be triggered by the tag push."