use crate::{Match, PatternDetector};
use lazy_static::lazy_static;
use regex::Regex;
use std::path::Path;

lazy_static! {
    // Hallucinated API patterns - APIs that LLMs commonly generate but don't exist
    pub static ref HALLUCINATED_API_REGEX: Regex = Regex::new(
        r"(?i)\.(authenticate|validateInput|sanitize|encryptData|hashPassword|secureRandom)\s*\(\s*\)"
    ).unwrap();

    pub static ref INCOMPLETE_API_REGEX: Regex = Regex::new(
        r"(?:jwt\.sign\([^,)]*\)$|bcrypt\.hash\([^,)]*\)$|crypto\.createHash\([^)]*\)\.update\([^)]*\)$)"
    ).unwrap();

    // SQL Injection patterns commonly generated by LLMs
    pub static ref SQL_INJECTION_REGEX: Regex = Regex::new(
        r#"(?i)["'](?:SELECT|INSERT|UPDATE|DELETE)\s+.*["']\s*\+|query\s*\(\s*[^?].*\+|\$\{[^}]*\}.*(?:SELECT|INSERT)"#
    ).unwrap();

    // Insecure random patterns
    pub static ref INSECURE_RANDOM_REGEX: Regex = Regex::new(
        r"(?:Math\.random\(\)|Random\(\)\.nextInt|rand\(\)|random\.randint).*(?:password|token|key|secret|salt)"
    ).unwrap();

    // Hardcoded credentials patterns
    pub static ref HARDCODED_CREDENTIALS_REGEX: Regex = Regex::new(
        r#"(?i)(?:password|api_key|secret|token|private_key)\s*[:=]\s*["'][^"']{8,}["']"#
    ).unwrap();

    // Memory safety issues in Rust (LLM-specific patterns)
    pub static ref RUST_MEMORY_SAFETY_REGEX: Regex = Regex::new(
        r"(?:\.unwrap\(\)\s*;?\s*//.*safe|unsafe\s*\{[^}]*\}\s*//.*safe|transmute\s*\(|Box::from_raw\s*\()"
    ).unwrap();

    // Async/await anti-patterns
    pub static ref ASYNC_ANTIPATTERN_REGEX: Regex = Regex::new(
        r"(?:await\s+\w+\s*;|\.then\(\s*await|return\s+await\s+Promise\.resolve|Promise\.all\([^)]*\)\s*;)"
    ).unwrap();

    // Performance anti-patterns
    pub static ref PERFORMANCE_ANTIPATTERN_REGEX: Regex = Regex::new(
        r"(?:for.*for.*for.*for|\.sort\(\).*\.sort\(\)|\.clone\(\)\.clone\(\)|Vec::new\(\).*\.push.*for.*in)"
    ).unwrap();

    // Error handling issues
    pub static ref ERROR_HANDLING_REGEX: Regex = Regex::new(
        r"(?:catch\s*\([^)]*\)\s*\{\s*\}|except\s*[^:]*:\s*pass|\.map_err\(.*\)\.unwrap\(\)|panic!\(.*result)"
    ).unwrap();

    // Cryptographic anti-patterns
    pub static ref CRYPTO_ANTIPATTERN_REGEX: Regex = Regex::new(
        r"(?i)(?:MD5|SHA1|DES|RC4)\s*\(|AES.*ECB|new\s+Random\(\).*(?:key|salt)"
    ).unwrap();

    // Over-engineering patterns
    pub static ref OVERENGINEERING_REGEX: Regex = Regex::new(
        r"(?:class.*Factory.*Factory|AbstractFactoryBuilder|\.map\(.*\)\.map\(.*\)\.map\()"
    ).unwrap();

    // XSS and injection vulnerabilities
    pub static ref XSS_INJECTION_REGEX: Regex = Regex::new(
        r"(?:innerHTML\s*=.*\+|document\.write\(.*\+|eval\(.*request\.|exec\(.*input.*\))"
    ).unwrap();

    // File system security issues
    pub static ref FILESYSTEM_SECURITY_REGEX: Regex = Regex::new(
        r"(?:open\(.*\+.*['\x22].*w|File\(.*\+.*\)|\.\.\/.*\.\.\/|Path\.join\(.*input)"
    ).unwrap();

    // Configuration anti-patterns
    pub static ref CONFIG_ANTIPATTERN_REGEX: Regex = Regex::new(
        r"(?:localhost:\d+|127\.0\.0\.1:\d+|http://[^\x22]*[\x22]|port.*=.*\d{4,5})"
    ).unwrap();

    // JavaScript-specific LLM issues
    pub static ref JS_LLM_ISSUES_REGEX: Regex = Regex::new(
        r"(?:==.*null|!=.*undefined|JSON\.parse\([^)]*\)\s*;|parseInt\([^,)]*\))"
    ).unwrap();

    // Python-specific LLM issues
    pub static ref PYTHON_LLM_ISSUES_REGEX: Regex = Regex::new(
        r"(?:exec\(.*input\(|eval\(.*input\(|pickle\.loads\(.*request|__import__\(.*input)"
    ).unwrap();

    // Context confusion patterns
    pub static ref CONTEXT_CONFUSION_REGEX: Regex = Regex::new(
        r"(?:sudo.*\|\|.*su\s|system\(.*\+.*\)|process\.env\..*\|\|.*[\x22])"
    ).unwrap();

    // Database anti-patterns
    pub static ref DATABASE_ANTIPATTERN_REGEX: Regex = Regex::new(
        r"(?i)(?:SELECT \* FROM|for.*in.*\.execute\(|WHERE.*LIKE\s*\x27%.*%\x27)"
    ).unwrap();

    // LLM-specific comment patterns that indicate AI generation
    pub static ref LLM_GENERATED_COMMENTS_REGEX: Regex = Regex::new(
        r"(?i)//.*(?:ai generated|generated by|gpt|claude|chatgpt|copilot|based on|as an ai)"
    ).unwrap();
}

fn detect_pattern_with_context(
    content: &str,
    file_path: &Path,
    pattern_name: &str,
    re: &Regex,
) -> Vec<Match> {
    let mut matches = Vec::new();
    for (line_idx, line) in content.lines().enumerate() {
        for mat in re.find_iter(line) {
            let context_start = mat.start().saturating_sub(15);
            let context_end = (mat.end() + 25).min(line.len());
            let context = &line[context_start..context_end];

            matches.push(Match {
                file_path: file_path.to_string_lossy().to_string(),
                line_number: line_idx + 1,
                column: mat.start() + 1,
                pattern: pattern_name.to_string(),
                message: format!("{}: {}", pattern_name, context.trim()),
            });
        }
    }
    matches
}

/// Detector for hallucinated APIs commonly generated by LLMs
pub struct HallucinatedApiDetector;

impl PatternDetector for HallucinatedApiDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        let mut matches = detect_pattern_with_context(
            content,
            file_path,
            "LLM_HALLUCINATED_API",
            &HALLUCINATED_API_REGEX,
        );

        matches.extend(detect_pattern_with_context(
            content,
            file_path,
            "LLM_INCOMPLETE_API",
            &INCOMPLETE_API_REGEX,
        ));

        matches
    }
}

/// Detector for SQL injection vulnerabilities common in LLM-generated code
pub struct LLMSQLInjectionDetector;

impl PatternDetector for LLMSQLInjectionDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_SQL_INJECTION",
            &SQL_INJECTION_REGEX,
        )
    }
}

/// Detector for insecure random number generation in security contexts
pub struct InsecureRandomDetector;

impl PatternDetector for InsecureRandomDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_INSECURE_RANDOM",
            &INSECURE_RANDOM_REGEX,
        )
    }
}

/// Detector for hardcoded credentials in LLM-generated code
pub struct HardcodedCredentialsDetector;

impl PatternDetector for HardcodedCredentialsDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_HARDCODED_CREDENTIALS",
            &HARDCODED_CREDENTIALS_REGEX,
        )
    }
}

/// Detector for memory safety issues in Rust code generated by LLMs
pub struct RustMemorySafetyDetector;

impl PatternDetector for RustMemorySafetyDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        if let Some(ext) = file_path.extension() {
            if ext == "rs" {
                return detect_pattern_with_context(
                    content,
                    file_path,
                    "LLM_RUST_MEMORY_SAFETY",
                    &RUST_MEMORY_SAFETY_REGEX,
                );
            }
        }
        Vec::new()
    }
}

/// Detector for async/await anti-patterns
pub struct AsyncAntipatternDetector;

impl PatternDetector for AsyncAntipatternDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        if let Some(ext) = file_path.extension() {
            let ext_str = ext.to_string_lossy();
            if matches!(ext_str.as_ref(), "js" | "ts" | "jsx" | "tsx" | "rs") {
                return detect_pattern_with_context(
                    content,
                    file_path,
                    "LLM_ASYNC_ANTIPATTERN",
                    &ASYNC_ANTIPATTERN_REGEX,
                );
            }
        }
        Vec::new()
    }
}

/// Detector for performance anti-patterns in LLM code
pub struct PerformanceAntipatternDetector;

impl PatternDetector for PerformanceAntipatternDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_PERFORMANCE_ISSUE",
            &PERFORMANCE_ANTIPATTERN_REGEX,
        )
    }
}

/// Detector for poor error handling patterns
pub struct ErrorHandlingDetector;

impl PatternDetector for ErrorHandlingDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_ERROR_HANDLING",
            &ERROR_HANDLING_REGEX,
        )
    }
}

/// Detector for cryptographic anti-patterns
pub struct CryptoAntipatternDetector;

impl PatternDetector for CryptoAntipatternDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_CRYPTO_ANTIPATTERN",
            &CRYPTO_ANTIPATTERN_REGEX,
        )
    }
}

/// Detector for over-engineering patterns
pub struct OverengineeringDetector;

impl PatternDetector for OverengineeringDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_OVERENGINEERING",
            &OVERENGINEERING_REGEX,
        )
    }
}

/// Detector for XSS and code injection vulnerabilities
pub struct XSSInjectionDetector;

impl PatternDetector for XSSInjectionDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_XSS_INJECTION",
            &XSS_INJECTION_REGEX,
        )
    }
}

/// Detector for file system security issues
pub struct FilesystemSecurityDetector;

impl PatternDetector for FilesystemSecurityDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_FILESYSTEM_SECURITY",
            &FILESYSTEM_SECURITY_REGEX,
        )
    }
}

/// Detector for configuration anti-patterns
pub struct ConfigAntipatternDetector;

impl PatternDetector for ConfigAntipatternDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_CONFIG_ANTIPATTERN",
            &CONFIG_ANTIPATTERN_REGEX,
        )
    }
}

/// Detector for JavaScript-specific LLM issues
pub struct JSLLMIssuesDetector;

impl PatternDetector for JSLLMIssuesDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        if let Some(ext) = file_path.extension() {
            let ext_str = ext.to_string_lossy();
            if matches!(
                ext_str.as_ref(),
                "js" | "ts" | "jsx" | "tsx" | "vue" | "svelte"
            ) {
                return detect_pattern_with_context(
                    content,
                    file_path,
                    "LLM_JS_ISSUES",
                    &JS_LLM_ISSUES_REGEX,
                );
            }
        }
        Vec::new()
    }
}

/// Detector for Python-specific LLM issues
pub struct PythonLLMIssuesDetector;

impl PatternDetector for PythonLLMIssuesDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        if let Some(ext) = file_path.extension() {
            if ext == "py" {
                return detect_pattern_with_context(
                    content,
                    file_path,
                    "LLM_PYTHON_ISSUES",
                    &PYTHON_LLM_ISSUES_REGEX,
                );
            }
        }
        Vec::new()
    }
}

/// Detector for security context confusion
pub struct ContextConfusionDetector;

impl PatternDetector for ContextConfusionDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_CONTEXT_CONFUSION",
            &CONTEXT_CONFUSION_REGEX,
        )
    }
}

/// Detector for database anti-patterns
pub struct DatabaseAntipatternDetector;

impl PatternDetector for DatabaseAntipatternDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_DATABASE_ANTIPATTERN",
            &DATABASE_ANTIPATTERN_REGEX,
        )
    }
}

/// Detector for comments indicating LLM-generated code
pub struct LLMGeneratedCommentsDetector;

impl PatternDetector for LLMGeneratedCommentsDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        detect_pattern_with_context(
            content,
            file_path,
            "LLM_GENERATED_COMMENT",
            &LLM_GENERATED_COMMENTS_REGEX,
        )
    }
}

/// Comprehensive LLM vulnerability detector that combines multiple patterns
pub struct ComprehensiveLLMDetector {
    detectors: Vec<Box<dyn PatternDetector>>,
}

impl ComprehensiveLLMDetector {
    pub fn new() -> Self {
        let detectors: Vec<Box<dyn PatternDetector>> = vec![
            Box::new(HallucinatedApiDetector),
            Box::new(LLMSQLInjectionDetector),
            Box::new(InsecureRandomDetector),
            Box::new(HardcodedCredentialsDetector),
            Box::new(RustMemorySafetyDetector),
            Box::new(AsyncAntipatternDetector),
            Box::new(PerformanceAntipatternDetector),
            Box::new(ErrorHandlingDetector),
            Box::new(CryptoAntipatternDetector),
            Box::new(OverengineeringDetector),
            Box::new(XSSInjectionDetector),
            Box::new(FilesystemSecurityDetector),
            Box::new(ConfigAntipatternDetector),
            Box::new(JSLLMIssuesDetector),
            Box::new(PythonLLMIssuesDetector),
            Box::new(ContextConfusionDetector),
            Box::new(DatabaseAntipatternDetector),
            Box::new(LLMGeneratedCommentsDetector),
        ];

        Self { detectors }
    }
}

impl Default for ComprehensiveLLMDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl PatternDetector for ComprehensiveLLMDetector {
    fn detect(&self, content: &str, file_path: &Path) -> Vec<Match> {
        let mut all_matches = Vec::new();

        for detector in &self.detectors {
            all_matches.extend(detector.detect(content, file_path));
        }

        all_matches
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_hallucinated_api_detector() {
        let detector = HallucinatedApiDetector;
        let content = "user.authenticate(); data.validateInput(); crypto.secureRandom();";
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert!(matches.len() >= 3);
        assert!(matches.iter().any(|m| m.pattern == "LLM_HALLUCINATED_API"));
    }

    #[test]
    fn test_sql_injection_detector() {
        let detector = LLMSQLInjectionDetector;
        let content = r#"query("SELECT * FROM users WHERE id = " + userId);"#;
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert_eq!(matches.len(), 1);
        assert_eq!(matches[0].pattern, "LLM_SQL_INJECTION");
    }

    #[test]
    fn test_hardcoded_credentials_detector() {
        let detector = HardcodedCredentialsDetector;
        let content =
            r#"const password = "mySecretPass123"; const api_key = "sk-1234567890abcdef";"#;
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert!(matches.len() >= 2);
        assert!(matches
            .iter()
            .any(|m| m.pattern == "LLM_HARDCODED_CREDENTIALS"));
    }

    #[test]
    fn test_rust_memory_safety_detector() {
        let detector = RustMemorySafetyDetector;
        let content =
            "let value = ptr.unwrap(); // safe because we checked\nunsafe { transmute(data) }";
        let path = PathBuf::from("test.rs");
        let matches = detector.detect(content, &path);
        assert!(!matches.is_empty());
        assert_eq!(matches[0].pattern, "LLM_RUST_MEMORY_SAFETY");
    }

    #[test]
    fn test_async_antipattern_detector() {
        let detector = AsyncAntipatternDetector;
        let content =
            "await someVar; data.then(await processData); return await Promise.resolve(value);";
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert!(!matches.is_empty());
        assert_eq!(matches[0].pattern, "LLM_ASYNC_ANTIPATTERN");
    }

    #[test]
    fn test_crypto_antipattern_detector() {
        let detector = CryptoAntipatternDetector;
        let content = "const hash = MD5(password); const cipher = AES.ECB.encrypt(data);";
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert!(!matches.is_empty());
        assert_eq!(matches[0].pattern, "LLM_CRYPTO_ANTIPATTERN");
    }

    #[test]
    fn test_js_llm_issues_detector() {
        let detector = JSLLMIssuesDetector;
        let content = "if (value == null) { } parseInt(str); JSON.parse(data);";
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert!(matches.len() >= 2);
        assert_eq!(matches[0].pattern, "LLM_JS_ISSUES");
    }

    #[test]
    fn test_python_llm_issues_detector() {
        let detector = PythonLLMIssuesDetector;
        let content = "exec(input('Enter code: ')); eval(user_input); pickle.loads(request.data);";
        let path = PathBuf::from("test.py");
        let matches = detector.detect(content, &path);
        assert!(matches.len() >= 2);
        assert_eq!(matches[0].pattern, "LLM_PYTHON_ISSUES");
    }

    #[test]
    fn test_comprehensive_llm_detector() {
        let detector = ComprehensiveLLMDetector::new();
        let content = r#"
            user.authenticate(); // Common LLM hallucination
            const password = "hardcoded123";
            query("SELECT * FROM users WHERE id = " + id);
            if (value == null) { }
        "#;
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);

        // Should detect multiple issues
        assert!(matches.len() >= 3);

        let patterns: Vec<&str> = matches.iter().map(|m| m.pattern.as_str()).collect();
        assert!(patterns.contains(&"LLM_HALLUCINATED_API"));
        assert!(patterns.contains(&"LLM_HARDCODED_CREDENTIALS"));
        assert!(patterns.contains(&"LLM_SQL_INJECTION"));
    }

    #[test]
    fn test_llm_generated_comments_detector() {
        let detector = LLMGeneratedCommentsDetector;
        let content = "// This code was generated by ChatGPT\n// AI generated function\n// Based on GPT-4 suggestions";
        let path = PathBuf::from("test.js");
        let matches = detector.detect(content, &path);
        assert!(matches.len() >= 2);
        assert!(matches.iter().all(|m| m.pattern == "LLM_GENERATED_COMMENT"));
    }

    #[test]
    fn test_database_antipattern_detector() {
        let detector = DatabaseAntipatternDetector;
        let content = "SELECT * FROM users; for user in users: db.execute(query);";
        let path = PathBuf::from("test.sql");
        let matches = detector.detect(content, &path);
        assert!(!matches.is_empty());
        assert_eq!(matches[0].pattern, "LLM_DATABASE_ANTIPATTERN");
    }

    #[test]
    fn test_file_extension_filtering() {
        let rust_detector = RustMemorySafetyDetector;
        let js_detector = JSLLMIssuesDetector;
        let python_detector = PythonLLMIssuesDetector;

        let content = "transmute(data); parseInt(str); exec(input());";

        let rust_path = PathBuf::from("test.rs");
        let js_path = PathBuf::from("test.js");
        let py_path = PathBuf::from("test.py");
        let txt_path = PathBuf::from("test.txt");

        // Rust detector should only work on .rs files
        assert!(!rust_detector.detect(content, &rust_path).is_empty());
        assert_eq!(rust_detector.detect(content, &js_path).len(), 0);

        // JS detector should only work on JS/TS files
        assert!(!js_detector.detect(content, &js_path).is_empty());
        assert_eq!(js_detector.detect(content, &txt_path).len(), 0);

        // Python detector should only work on .py files
        assert!(!python_detector.detect(content, &py_path).is_empty());
        assert_eq!(python_detector.detect(content, &js_path).len(), 0);
    }
}
